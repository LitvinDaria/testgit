package comlib;

import java.io.UnsupportedEncodingException;
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/******************************************************************************
* Класс <code>Common</code> является хранилищем общих функций для работы
* программы, не зависящих от специфики самой программы. Все методы класса
* объявлены статически, поэтому не нужно создавать экземпляр класса, чтобы
* вызывать эти функции.
*
* <p> Пример:
* <blockquote><pre>Common.trim("string");</pre></blockquote>
******************************************************************************/
public class Common {
  static private SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
  static private SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");
  static private int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};
  static private int daysv[] = {31,29,31,30,31,30,31,31,30,31,30,31};

/******************************************************************************
* Конструктор класса <code>Common</code>. Не выполняет никаких действий.
* Все методы класса доступны статически, поэтому этот конструктор не должен
* вызываться.
******************************************************************************/
  public Common() {
  }
/******************************************************************************
* Отбрасывает начальные и конечные пробелы и другие служебные символы, оставляя
* только значение строки. Также заменяет слеши во всех escape-последовательностях.
* Если параметр <code>null</code>, то возвращает пустую строку (не <code>null</code>).
*
* @param str исходная строка для преобразования
*
* @return новая строка, являющаяся результатом работы функции
******************************************************************************/
  static public String trim(String str){
    return str == null ? "" : str.trim().replace("\\","&#92;");
  }
/******************************************************************************
* Отбрасывает начальные и конечные пробелы и другие служебные символы, оставляя
* только значение строки, и меняет кодировку для нормального представления строки,
* переданной в качестве параметра запроса.
* Если параметр <code>null</code>, то возвращает пустую строку (не <code>null</code>).
*
* @param str исходная строка для преобразования
*
* @return новая строка, являющаяся результатом работы функции
******************************************************************************/
  static public String trimUrl(String str){
    try {
      return str == null ? "" :
        new String(str.getBytes("ISO-8859-1"),"Cp1251").trim().replace("\\","&#92;");
    } catch (UnsupportedEncodingException ex) {
      ex.printStackTrace();
      return "";
    }
  }
  /******************************************************************************
* Отбрасывает начальные и конечные пробелы и другие служебные символы, оставляя
* только значение строки, и меняет кодировку для нормального представления строки,
* переданной в качестве параметра запроса.
* Если параметр <code>null</code>, то возвращает пустую строку (не <code>null</code>).
*
* @param str исходная строка для преобразования
*
* @return новая строка, являющаяся результатом работы функции
******************************************************************************/
  static public String trimUrl2(String str){
    try {
      return str == null ? "" :
        new String(str.getBytes("ISO-8859-1"),"UTF-8").trim().replace("\\","&#92;");
    } catch (UnsupportedEncodingException ex) {
      ex.printStackTrace();
      return "";
    }
  }
/******************************************************************************
* Осуществляет преобразование строки из формата строки, задающий URL в UNICODE
* в обычную строку. В строке URL каждый UNICODE-символ хранится в двух соседних
* ячейках строки, обеспечивая таким образом совместимость с браузерами. Функция
* <code>url2str</code> принимает нечетные символы в качестве верхнего байта, а
* четные - в качестве нижнего байта 16-ти разрядного символа в формате UNICODE.
* Формирование URL строки осуществляется на стороне клиента средствами JavaScript.
*
* @param str исходная строка для преобразования
*
* @return новая строка, являющаяся результатом работы функции
******************************************************************************/
  static public String url2str(String str){
    if (str == null) return "";
    String res = "";
    int code[] = new int[1];
    for (int i=0; i < str.length(); i+=2){
      code[0] = (str.codePointAt(i)<<8) + str.codePointAt(i+1);
      res += new String(code,0,1);
    }
    return res;
  }
/******************************************************************************
* Преобразует объект даты в строковое представление даты в формате "ДД.ММ.ГГГГ",
* где ДД - двузначный номер дня в месяце от 1 до 31,
* ММ - двузначный номер месяца от 1 до 12, ГГГГ - четырехзначный номер года.
* В случае, если параметр <code>null</code>, то возвращает пустую строку.
*
* <p>Пример:
* <blockquote><pre>Common.str2date("05.06.2007");</pre></blockquote>
*
* @param dt объект даты
*
* @return строка, являющаяся строковым представлением даты
******************************************************************************/
  static public String date2str(Date dt){
    return (dt == null) ? "" : sdf.format(dt);
  }
/******************************************************************************
* Осуществляет преобразование строки даты в любом формате в объект даты.
*
* @param str строковое представление даты
*
* @return объект даты в случае успешного преобразования
*
* @throws ParseException
*         в случае неверного представления даты в строковом виде
******************************************************************************/
  static public Date str2date(String str) throws ParseException{
    if (str == null || str.length() == 0)
      return null;
    try {
      if (str.length() != 10 || str.charAt(2) != '.' || str.charAt(5) != '.')
        throw new ParseException("Ошибка: неверный формат даты.",0);
      int d = Integer.parseInt(str.substring(0,2));
      int m = Integer.parseInt(str.substring(3,5));
      int y = Integer.parseInt(str.substring(6,10));

      if (m < 1 || m > 12 || y < 1000 && y > 9999)
        throw new ParseException("Ошибка: неверный формат даты.",0);
      if (y%4 != 0){
        if (d > days[m-1] || d < 1)
          throw new ParseException("Ошибка: неверный формат даты.",0);
      } else
      if (d > daysv[m-1] || d < 1)
         throw new ParseException("Ошибка: неверный формат даты.",0);

      Calendar c = Calendar.getInstance();
      c.set(y,m-1,d);
      return c.getTime();
    }
    catch (NumberFormatException e){
      throw new ParseException("",0);
    }
  }
/******************************************************************************
* Преобразует строковое представление целого числа в число. Если формат числа
* неверный, то возвращается значение по-умолчанию.
*
* @param str исходная строка для преобразования
* @param def значение по-умолчанию, возвращаемое в случае ошибки преобразования
*
* @return целое число
******************************************************************************/
  static public int str2int(String str, int def){
    try {
      return Integer.parseInt(str);
    } catch (NumberFormatException e){
      return def;
    }
  }
/******************************************************************************
* Преобразует строковое представление целого числа в число. Если формат числа
* неверный, то возвращается значение по-умолчанию.
*
* @param str исходная строка для преобразования
* @param def значение по-умолчанию, возвращаемое в случае ошибки преобразования
*
* @return целое число
******************************************************************************/
  static public long str2long(String str, long def){
    try {
      return Long.parseLong(str);
    } catch (NumberFormatException e){
      return def;
    }
  }
/******************************************************************************
* Преобразует строковое представление страхового номера застрахованного лица
* (СНИЛС) в формате "000-000-000 00" или в формате "000-000-000" в число с
* плавающей точкой, целая часть которого является числовым значением
* страхового номера, а десятичная - контрольной суммой. Если в исходной строке
* отсутствует страховой номер, то десятичная часть также будет отсутствовать.
*
* <p>Пример:
* <blockquote><pre>float num = Common.str2ins("123-456-789 64");</pre></blockquote>
* Значение <code>num</code> составляет 123456789.64
*
* @param str исходная строка для преобразования
*
* @return число с плавающей точкой, являющееся числовым представлением СНИЛС
*
* @throws NumberFormatException
*         в случае неверного представления СНИЛС в строковом виде
******************************************************************************/
  static public double str2snils(String str) throws NumberFormatException{
    String tmp[] = Common.trim(str).split("-");
    if (tmp.length != 3 || tmp[0].length() != 3 || tmp[1].length() != 3
                        || tmp[2].length() != 6 && tmp[2].length() != 3)
      throw new NumberFormatException("Неверный формат СНИЛС!");

    if (tmp[2].length() == 6){
      String tmp2[] = tmp[2].split(" ");
      if (tmp2.length != 2 || tmp2[0].length() != 3 || tmp2[1].length() != 2)
        throw new NumberFormatException("Неверный формат СНИЛС!");
      tmp[2] = tmp2[0] + "." + tmp2[1];
    }

    return Double.parseDouble(tmp[0]+tmp[1]+tmp[2]);
  }
/******************************************************************************
* Преобразует числовое представление страхового номера в строковое в формате
* "000-000-000" без контрольной суммы.
*
* @param num целая часть числового представления страхового номера
*
* @return строковое представление страхового номера без контрольной суммы
******************************************************************************/
  static public String snils2str(int num){
    String str = String.valueOf(num);
    while (str.length() < 9) str = "0"+str;
    return str.replaceAll("^(\\d{3})(\\d{3})(\\d{3})$","$1-$2-$3");
  }
/******************************************************************************
* Преобразует числовое представление страхового номера в строковое в формате
* "000-000-000 00" c контрольной суммой.
*
* @param num числовое представление страхового номера
*
* @return строковое представление страхового номера с контрольной суммой
******************************************************************************/
  static public String snils2str2(int num){
    String str = String.valueOf(num);

    int res = 0;
    int j = 1;
    for (int i=str.length()-1; i >= 0; i--, j++)
      res += Integer.parseInt(str.substring(i,i+1))*j;

    while (str.length() < 9) str = "0"+str;

    return str.replaceAll("^(\\d{3})(\\d{3})(\\d{3})$","$1-$2-$3 ") + String.valueOf(res);
  }
/******************************************************************************
* Преобразует числовое представление регистрационного номера в строковое в формате
* "000-000-000000".
*
* @param num числовое представление регистрационного номера
*
* @return строковое представление регистрационного номера
******************************************************************************/
  static public String insnmb2str(long num){
    String str = String.valueOf(num);
    while (str.length() < 12) str = "0" + str;
    return str.replaceAll("^(\\d{3})(\\d{3})(\\d{6})$","$1-$2-$3");
  }
/******************************************************************************
* Преобразует числовое представление полного № района в строковое в формате
* "000-000".
*
* @param num числовое представление номера района
*
* @return строковое представление регистрационного номера
******************************************************************************/
  static public String region2str(int num){
    String str = String.valueOf(num);
    while (str.length() < 6) str = "0" + str;
    return str.replaceAll("^(\\d{3})(\\d{3})$","$1-$2");
  }
/******************************************************************************
* Преобразует числовое представление номера реестра в строковое в формате
* "год/номер".
*
* @param num числовое представление номера района
*
* @return строковое представление регистрационного номера
******************************************************************************/
  static public String regnmb2str(int num){
    return (String.valueOf(num).length() <= 4) ? "" :
      String.valueOf(num/10000) + "/" + String.valueOf(num%10000);
  }
 /******************************************************************************
* Преобразует числовое представление вх.номера в строковое в формате "год/номер-копия".
*
* @param num числовое представление номера района
*
* @return строковое представление регистрационного номера
******************************************************************************/
  static public String inpnmb2str(long num){
    return (String.valueOf(num).length() != 14) ? "" :
      String.valueOf(num/10000000000L) + "/" + String.valueOf((num/1000)%10000000L) +
        (num%1000 != 0 ? String.valueOf(num/1000) : "");
  }
/******************************************************************************
* Вычисляет контрольную сумму для числового представления страхового номера.
* Контрольная сумма cтрахового номера рассчитывается следующим образом:
* <p>каждая цифра страхового номера умножается на номер своей позиции (позиции
* отсчитываются с конца), полученные произведения суммируются, сумма делится
* на 101, последние две цифры остатка от деления являются контрольной суммой.
*
* @param num числовое представление страхового номера без десятичной части
*
* @return числовое представление контрольной суммы для указанного СНИЛСа
******************************************************************************/
  static public int GetChecksum(int num){
    String s = String.valueOf(num);
    int res = 0;
    int j = 1;
    for (int i=s.length()-1; i >= 0; i--, j++)
      res += Integer.parseInt(s.substring(i,i+1))*j;

    return (res % 101)%100;
  }
/******************************************************************************
* Преобразование строки со списком значений в условие поиска для SQL-запроса.
* Список диапазонов представляет собой перечисление через "," отдельных значений
* и диапазонов значений. Диапазоны значений состоят из двух значений,
* разделенных знаком "-", при этом первое значение должно быть меньше второго.
* Все пробелы между знаками игнорируются. Все значения должный быть
* неотрицательными. Если исходная строка <code>null</code>, то возвращает
* пустую строку.
*
* <p>Пример:
* <blockquote><pre>Common.parseRanges("1,3-5,8,9","id");</pre></blockquote>
* Результататом будет строка "id IN(1,8,9) OR id >=3 AND id <= 5"
*
* @param str   исходная строка
* @param field имя поля, на которое накладывается условие поиска
*
* @return строка, содержащая условие поиска для SQL-запроса
******************************************************************************/
  static public String parseRanges (String str, String field){
    if (str == null) return "";
    String[] ranges = (str.length() > 0) ? str.split(",") : new String[0];
    String where1 = "";
    String where2 = "";
    for (int i=0; i < ranges.length; i++){
      ranges[i] = Common.trim(ranges[i]);
      String[] range = (ranges[i].length() > 0) ? ranges[i].split("-") : new String[0];
      switch (range.length){
        case 1:// Если нет знака "-", то поле обрабатывается как одиночное значение
            range[0] = Common.trim(range[0]);
            if (Common.str2int(range[0], -1) >= 0){
              if (where1.length() > 0)
                where1 += ",";
              where1 += range[0];
            }
          break;
        case 2: // Если есть один знак "-", то поле обрабатывается как диапазон
            range[0] = Common.trim(range[0]);
            range[1] = Common.trim(range[1]);
            if (Common.str2int(range[0], -1) >= 0 && Common.str2int(range[1], -1) >= 0){
              if (where2.length() > 0)
                where2 += " OR ";
              where2 += field + ">=" + range[0] + " AND "+field+"<=" + range[1];
            }
          break;
        // Во всех остальных случаях поле считается ошибочным и игнорируется
      }
    }
    if (where1.length() > 0){
      if (where2.length() > 0)
        where2 += " OR ";
      where2 += field + " IN("+where1+")";
    }
    return where2;
  }
/******************************************************************************
* Преобразование строки со списком значений в условие сортировки для SQL-запроса.
* Список полей представляет собой перечисление через "," номера поля и
* направление сортировки для этого поля, разделенных знаком "-".
* Номер поля должен быть меньше длинны списка полей. Направление сортировки
* может принимать два значения: "0" - для сортировки по-возрастанию,
* "1" - по-убыванию. Строка не должна содержать никаких знаков, кроме
* вышеуказанных. В случае ошибки или если исходная строка <code>null</code>,
* то возвращает пустую строку.
*
* <p>Пример:
* <blockquote><pre>Common.parseOrder("0-1,1-0",["code","name"]);</pre></blockquote>
* Результататом будет строка "code DESC, name"
*
* @param str    исходная строка
* @param fields список полей, по которым производится упорядочивание
*
* @return строка, содержащая условие сортировки для SQL-запроса
******************************************************************************/
  static public String parseOrder (String str, String[] fields){
    if (str == null ||  fields == null) return "";
    String[] ranges = (str.length() > 0) ? str.split(",") : new String[0];
    String order = "";
    for (int i=0; i < ranges.length; i++){
      ranges[i] = Common.trim(ranges[i]);
      String[] range = (ranges[i].length() > 0) ? ranges[i].split("-") : new String[0];
      if (range.length == 2){
        range[0] = Common.trim(range[0]);
        range[1] = Common.trim(range[1]);
        int field = Common.str2int(range[0], fields.length);
        if ( field < fields.length){
          if (order.length() > 0)
            order += ", ";
          order += fields[ field ];
          if (range[1].equals("1"))
            order += " DESC";
        }
      }
    }
    return order;
  }
/******************************************************************************
* Преобразование строки со списком значений в массив значений для JavaScript.
* Список полей представляет собой перечисление через "," номера поля и
* направление сортировки для этого поля, разделенных знаком "-".
* Номер поля должен быть меньше длинны списка полей. Направление сортировки
* может принимать два значения: "0" - для сортировки по-возрастанию,
* "1" - по-убыванию. Строка не должна содержать никаких знаков, кроме
* вышеуказанных. В случае ошибки или если исходная строка <code>null</code>,
* то возвращает пустую строку.
*
* <p>Пример:
* <blockquote><pre>Common.parseOrder("0-1,1-0");</pre></blockquote>
* Результататом будет строка "{field: 0, order: 1},{field: 1, order: 0}"
*
* @param str исходная строка
*
* @return строка, содержащая список значений в формате json
******************************************************************************/
  static public String parseOrder (String str){
    if (str == null) return "";
    String[] ranges = (str.length() > 0) ? str.split(",") : new String[0];
    String order = "";
    for (int i=0; i < ranges.length; i++){
      ranges[i] = Common.trim(ranges[i]);
      String[] range = (ranges[i].length() > 0) ? ranges[i].split("-") : new String[0];
      if (range.length == 2){
        range[0] = Common.trim(range[0]);
        range[1] = Common.trim(range[1]);
        if (Common.str2int(range[0], -1) >= 0){
          if (order.length() > 0)
            order += ", ";
          order += "{field: " + range[0] + ", order: " + range[1] + "}";
        }
      }
    }
    return order;
  }
/******************************************************************************
* Создает новое подключение к удаленной базе данных. При успешном установлении
* соединеия функция возвращает объект класса <code>java.sql.Connection
******************************************************************************/
  static public Connection CreateConnection(String base, String user, String pwd, boolean log)
  throws ClassNotFoundException, SQLException {
    Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
    if (log) DriverManager.setLogStream(System.out);
    return DriverManager.getConnection("jdbc:odbc:"+base, user, pwd);
  }
/*****************************************************************************
* Преобразует объект даты в строковое представление даты в формате "ГГГГ-ММ-ДД",
* где ДД - двузначный номер дня в месяце от 1 до 31,
* ММ - двузначный номер месяца от 1 до 12, ГГГГ - четырехзначный номер года.
* В случае, если параметр <code>null</code>, то возвращает пустую строку.
*
* <p>Пример:
* <blockquote><pre>Common.str2date("05.06.2007");</pre></blockquote>
*
* @param dt объект даты
*
* @return строка, являющаяся строковым представлением даты
******************************************************************************/
    static public String date2str2(Date dt){//Возвращает текщую дату
         return (dt == null) ? "" : sdf1.format(dt);
    }
/*****************************************************************************/
/*****************************************************************************
* Преобразует объект даты в строковое представление даты в формате "ГГГГ-ММ-ДД",
* где ДД - двузначный номер дня в месяце от 1 до 31,
* ММ - двузначный номер месяца от 1 до 12, ГГГГ - четырехзначный номер года.
* В случае, если параметр <code>null</code>, то возвращает пустую строку.
*
* <p>Пример:
* <blockquote><pre>Common.str2date("05.06.2007");</pre></blockquote>
*
* @param dt объект даты
*
* @return строка, являющаяся строковым представлением даты
******************************************************************************/
/*****************************************************************************
* Преобразует объект даты в строковое представление даты в формате "ГГГГ-ММ-ДД",
* где ДД - двузначный номер дня в месяце от 1 до 31,
* ММ - двузначный номер месяца от 1 до 12, ГГГГ - четырехзначный номер года.
* В случае, если параметр <code>null</code>, то возвращает пустую строку.
*
* <p>Пример:
* <blockquote><pre>Common.str2date("05.06.2007");</pre></blockquote>
*
* @param dt объект даты
*
* @return строка, являющаяся строковым представлением даты
******************************************************************************/
static public String datFormat(String str){
    return (str == null)? "":str.substring(6, str.length())+"-"+str.substring(3, 5)+
            "-"+str.substring(0, 2);
  //  if(str.length()<10) return "";
   // return (str.equals(""))? "": str.substring(6, str.length())+"-"+str.substring(3, 5)+
    //        "-"+str.substring(0, 2);
}
}
